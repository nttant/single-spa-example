# single-spa-example

## Overview

This is a small demo using [single-spa](https://single-spa.js.org) with [systemjs](https://github.com/systemjs/systemjs) import maps to setup a microfrontend architecture

It is possible to use Webpack 5 Module Federation instaed of System JS import maps with single-spa, but this demo does not expore that option, and single-spa development team recommends that import maps are used instaed.

It is possible to use server-side rendering with single-spa but that is outside of the scope of this demo. For more information see [single-spa server side rendering](https://single-spa.js.org/docs/ssr-overview)

As far as I know, currently Next JS is not compatible to be used a microfrontend with single-spa but this might change in the future, so depends on when you are readung this.


## Getting started

Run the following commands. Note the ports must be the same as below. Don't swap them around.

```
cd app1
npm install
npm start -- --port 8080

cd ..

cd app2
npm install
npm start -- --port 8081

cd ..

cd header
npm install
npm start -- --port 8082

cd ..

cd footer
npm install
npm start -- --port 8083

cd ..

cd utils
npm install
npm start -- --port 8084

cd ..

cd root-config
npm install
// don't use a port for this one
npm start
```

Then visit [http://localhost:9000/](http://localhost:9000/)

Click on the top-level and second level nav items

## Brief Explanation

All of the above apps were created with create-single-spa, which was called by running ```npm init single-spa``` and then answering the questions in the cli

### root-config

The is the host app and it does not use any JavaScript framework. It controls the top-level routing and loads the other apps (micorforntends) depending which ones were set for a specific route.

This was created with create-single-spa and then se;ecting root-config option in the cli

The microfrontend apps do not have an index.html page. They all use the index.html page generated by root-config.

#### root-config/src/index.ejs

This contains a [systemjs](https://github.com/systemjs/systemjs) import map that loads the microfrontends as in-browser modules. It also loads react and react-dom libraries as in-browser modules so that all the microfrontends cna use them as external modules.

#### root-config/src/microfrontend-layout.html

This contains ```<root>``` and ```<application>``` components. The root components configure the routes, based on top-level routes and the application components load the microfrontends for each route. Notice that header and footer components have been set to be active on all top-level routes.

### header, footer, app1, app2

These are all React microfroneds that have been created with create-single-spa and selecting react app in the cli. This is similar to apps created with create-react-app but three important differences are:

- There is no index.html page
- In the exntry point of each app, the React app is wrapped in a lifecycles object, that then exposes bootstarp, mount and unmount functions in the public interface. see app1/src/btplc-app1.txs
- A webpack.config file is present in each of the apps

If you look at the package.json file for each of the apps, note that the app name is prefixed with @btplc/ so that you get @btplc/app1, @btplc/app2, @btplc/header etc. When create-single-spa was used for each app, it requested a company name. I used btplc (without the @) for each and then create-single-spa setup the names. It also setup the entry-point files for each app with a naming convention ```[companyname]-[appname].tsx``` so app1 entry point was created as ```btplc-app1.tsx```

When you start these apps, do not expect to see the app running in the browser. If you start app1 at port 8080 ```cd app1 && npm start -- --port 8080``` when you visit http://localhost:8080 you will see code and not the running app. This is because the app is set as a module that does not immediately execute.

### utils

This is a microfrontend but setup as a shared utility, so it its not a react app. It has ademo function in its ecntry point that is exported, and because utils is also setup as a microfrontend and included in the import map in root-config/src/index.ejs any of the apps that are included in the importmap can access its public functions.

This is a neat way to share state or even components between microfrontends.

utils app was created with create-single-spa but in the cli the option "none" was selected when asked which framework to use. I could have alternatively selected react as a framework and then exported whatever I wanted to share (functions or components or state utilities) across microfrontends in the entry point of the app. 

utils/src/btplc-utils.ts exports a function called getFeatureToggles that just returns some state for features that we may want to toggle on and off.

App 1 uses getFeatureToggles function from utils. For app1 to use this cross-microfrontend item, it needed to do two things:

- import the function like you would any other library. See app1/src/root.component.tsx ```import { getFeatureToggles } from '@btplc/utils'``` also above this line to stop typescript from trying to look for this module locally I needed to add ```// @ts-ignore-next-line``` above the external module import
- in app1 webpack.config.js we needed to tell webpack not to look for this module when building by setting it as an external module 

```
  const externals = ['@btplc/utils']
  
  return merge(defaultConfig, {
    // modify the webpack config however you'd like to by adding to this object
    externals,
  });
```

### app2

root-config takes care of top level roots and apps can use react router to set second level routes. ```/shop``` route for example is set by root-config and in app2 react-router is used to set phones and computers routes so we get ```/shop/phones``` and ```/shop/computers``` routes. See ```app2/src/root.component.tsx```
